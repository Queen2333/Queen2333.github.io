<html>
<!-- Head tag -->
<head>
  <meta charset="UTF-8">

  
  <title>
    力扣刷题总结（入门级） |
    Majesty&#39;s blog
  </title>
  


  <meta name="description" content="">
  <meta name="author" content="Alex">
  <meta property="og:title" content="力扣刷题总结（入门级）" />
  <meta property="og:description" content="" />
  <meta property='og:site_name' content='Majesty&#39;s blog' />
  <meta property="og:image" content="http://example.com/img/default.jpg" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:description" content="" />
  <meta name="twitter:title" content="力扣刷题总结（入门级）" />

  <meta name="twitter:image" content="http://example.com/img/default.jpg" />

  <script src="https://www.amcharts.com/lib/4/core.js"></script>
  <script src="https://www.amcharts.com/lib/4/charts.js"></script>
  <script src="https://www.amcharts.com/lib/4/themes/animated.js"></script>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz"
    crossorigin="anonymous">
  
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 5.3.0"></head>

<body>
    <!-- Menu -->
    <nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark page-navbar gradient">
  <div class="container">
    <a class="navbar-brand logo" href="http://example.com">
      Majesty&#39;s blog</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav"
      aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav mx-auto">
        <li class="nav-item item">
          
        <li class="nav-item item">
          <a class="nav-link" href="/">
            Home</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" href="/archives">
            🗂️Archives</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" target="_blank" rel="noopener" href="https://hexo.io/">
            Hexo</a>
        </li>
        
        </li>
      </ul>
    </div>
  </div>
</nav>

    <main class="page main-page">
        <div class="container blogPost">
    <div class="row">
        <div class="col-sm-9 px-md-5">
            <h2 class="blog-post-title">
                力扣刷题总结（入门级）
            </h2>
            <p class="meta">
                <i class="far fa-clock"></i>
                2022-04-09 
            </p>
            <!-- Content -->
            <h4 id="两数之和-–-哈希映射"><a href="#两数之和-–-哈希映射" class="headerlink" title="两数之和 – 哈希映射"></a>两数之和 – 哈希映射</h4><p>给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @param &#123;number&#125; target</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var twoSum &#x3D; function(nums, target) &#123;</span><br><span class="line">  if (!nums) return</span><br><span class="line"></span><br><span class="line">  let obj &#x3D; new Map()</span><br><span class="line">  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    let part &#x3D; target - nums[i]</span><br><span class="line">    if (obj.get(part) !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        return [obj.get(part), i]</span><br><span class="line">    &#125;</span><br><span class="line">    obj.set(nums[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两数之和-II-输入有序数组-–-哈希-二分法-双指针"><a href="#两数之和-II-输入有序数组-–-哈希-二分法-双指针" class="headerlink" title="两数之和 II - 输入有序数组 – 哈希/二分法/双指针"></a>两数之和 II - 输入有序数组 – 哈希/二分法/双指针</h4><p>给定一个已按照 非递减顺序排列   的整数数组  numbers ，请你从数组中找出两个数满足相加之和等于目标数  target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; numbers</span><br><span class="line">* @param &#123;number&#125; target</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var twoSum &#x3D; function(numbers, target) &#123;</span><br><span class="line">  let list &#x3D; new Map()</span><br><span class="line">  for (let i &#x3D; 0;i &lt; numbers.length; i++) &#123;</span><br><span class="line">    let cur &#x3D; target - numbers[i]</span><br><span class="line">    if (list.has(cur)) &#123;</span><br><span class="line">      return [list.get(cur) + 1, i + 1]</span><br><span class="line">    &#125;</span><br><span class="line">    list.set(numbers[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; numbers</span><br><span class="line">* @param &#123;number&#125; target</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var twoSum &#x3D; function(numbers, target) &#123;</span><br><span class="line">  let left &#x3D; 0</span><br><span class="line">  let right &#x3D; numbers.length - 1</span><br><span class="line">  while(left &lt; right) &#123;</span><br><span class="line">    if (numbers[left] + numbers[right] &#x3D;&#x3D;&#x3D; target) &#123;</span><br><span class="line">      return [left + 1, right + 1]</span><br><span class="line">    &#125; else if (numbers[left] + numbers[right] &gt; target) &#123;</span><br><span class="line">      right --</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      left ++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最长公共前缀-–-链表"><a href="#最长公共前缀-–-链表" class="headerlink" title="最长公共前缀 – 链表"></a>最长公共前缀 – 链表</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;string[]&#125; strs</span><br><span class="line">* @return &#123;string&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var longestCommonPrefix &#x3D; function(strs) &#123;</span><br><span class="line">  if (strs.length &#x3D;&#x3D;&#x3D; 0) return &#39;&#39;</span><br><span class="line">  let ans &#x3D; strs[0];</span><br><span class="line">  for(let i &#x3D;1;i&lt;strs.length;i++) &#123;</span><br><span class="line">    let j</span><br><span class="line">    for(j &#x3D; 0; j&lt;ans.length &amp;&amp; j &lt; strs[i].length; j++) &#123;</span><br><span class="line">      if(ans[j] !&#x3D; strs[i][j]) break;</span><br><span class="line">    &#125;</span><br><span class="line">    ans &#x3D; ans.substr(0, j);</span><br><span class="line">    if(ans &#x3D;&#x3D;&#x3D; &#39;&#39;) return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="有效的括号-–-栈"><a href="#有效的括号-–-栈" class="headerlink" title="有效的括号 – 栈"></a>有效的括号 – 栈</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’  的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">* @param &#123;string&#125; s</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"> var isValid &#x3D; function(s) &#123;</span><br><span class="line">   const n &#x3D; s.length</span><br><span class="line">   if (n % 2 !&#x3D;&#x3D; 0) return false</span><br><span class="line">   const map &#x3D; new Map([</span><br><span class="line">     [&#39;)&#39;, &#39;(&#39;],</span><br><span class="line">     [&#39;]&#39;, &#39;[&#39;],</span><br><span class="line">     [&#39;&#125;&#39;, &#39;&#123;&#39;]</span><br><span class="line">   ])</span><br><span class="line">   const stk &#x3D; []</span><br><span class="line">   for (let item of s) &#123;</span><br><span class="line">       if (map.has(item)) &#123;</span><br><span class="line">           if (map.get(item) !&#x3D;&#x3D; stk[stk.length - 1] || !stk.length) &#123;</span><br><span class="line">           return false</span><br><span class="line">           &#125;</span><br><span class="line">           stk.pop()</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           stk.push(item)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return !stk.length</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="合并两个有序链表-–-链表-递归"><a href="#合并两个有序链表-–-链表-递归" class="headerlink" title="合并两个有序链表 – 链表 递归"></a>合并两个有序链表 – 链表 递归</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* function ListNode(val, next) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;ListNode&#125; l1</span><br><span class="line">* @param &#123;ListNode&#125; l2</span><br><span class="line">* @return &#123;ListNode&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var mergeTwoLists &#x3D; function(l1, l2) &#123;</span><br><span class="line">  if (l1 &#x3D;&#x3D;&#x3D; null) return l2</span><br><span class="line">  if (l2 &#x3D;&#x3D;&#x3D; null) return l1</span><br><span class="line">  if (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next &#x3D; mergeTwoLists(l1.next, l2)</span><br><span class="line">    return l1</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    l2.next &#x3D; mergeTwoLists(l1, l2.next)</span><br><span class="line">    return l2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="删除有序数组中的重复项-–-双指针-快慢指针"><a href="#删除有序数组中的重复项-–-双指针-快慢指针" class="headerlink" title="删除有序数组中的重复项 – 双指针(快慢指针)"></a>删除有序数组中的重复项 – 双指针(快慢指针)</h4><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var removeDuplicates &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  if (n &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  let fast &#x3D; 1, slow &#x3D; 1;</span><br><span class="line">  while (fast &lt; n) &#123;</span><br><span class="line">    if (nums[fast] !&#x3D;&#x3D; nums[fast - 1]) &#123;</span><br><span class="line">      nums[slow] &#x3D; nums[fast];</span><br><span class="line">      ++slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ++fast;</span><br><span class="line">  &#125;</span><br><span class="line">  return slow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移除元素-–-双指针"><a href="#移除元素-–-双指针" class="headerlink" title="移除元素 – 双指针"></a>移除元素 – 双指针</h4><p>给你一个数组 nums  和一个值 val，你需要 原地 移除所有数值等于  val  的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @param &#123;number&#125; val</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var removeElement &#x3D; function(nums, val) &#123;</span><br><span class="line">  let n &#x3D; nums.length</span><br><span class="line">  let i &#x3D; 0</span><br><span class="line">  while (i &lt; n) &#123;</span><br><span class="line">    if (val &#x3D;&#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">      nums[i] &#x3D; nums[n - 1]</span><br><span class="line">      n--</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return n</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="实现-strStr-–-双指针"><a href="#实现-strStr-–-双指针" class="headerlink" title="实现 strStr() – 双指针"></a>实现 strStr() – 双指针</h4><p>实现  strStr()  函数。</p>
<p>给你两个字符串  haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回   -1 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;string&#125; haystack</span><br><span class="line">* @param &#123;string&#125; needle</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var strStr &#x3D; function(haystack, needle) &#123;</span><br><span class="line">  let l &#x3D; 0, n &#x3D; 0</span><br><span class="line">  while (l &lt; haystack.length &amp;&amp; n &lt; needle.length) &#123;</span><br><span class="line">    if (haystack[l + n] &#x3D;&#x3D;&#x3D; needle[n]) &#123;</span><br><span class="line">      n++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      n &#x3D; 0</span><br><span class="line">      l++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return n &#x3D;&#x3D;&#x3D; needle.length ? l : -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="搜索插入位置-–-二分法"><a href="#搜索插入位置-–-二分法" class="headerlink" title="搜索插入位置 – 二分法"></a>搜索插入位置 – 二分法</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @param &#123;number&#125; target</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var searchInsert &#x3D; function(nums, target) &#123;</span><br><span class="line"> const n &#x3D; nums.length;</span><br><span class="line">  let l &#x3D; 0, r &#x3D; n - 1</span><br><span class="line">  while(l &lt;&#x3D; r) &#123;</span><br><span class="line">      let mid &#x3D; Math.floor((r + l) &#x2F; 2)</span><br><span class="line">      if (target &#x3D;&#x3D;&#x3D; nums[mid]) &#123;</span><br><span class="line">          return mid</span><br><span class="line">      &#125; else if (target &lt; nums[mid]) &#123;</span><br><span class="line">          r &#x3D; mid - 1</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          l &#x3D; mid + 1</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return l</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最大子序和-–-动态规划"><a href="#最大子序和-–-动态规划" class="headerlink" title="最大子序和 – 动态规划"></a>最大子序和 – 动态规划</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var maxSubArray &#x3D; function(nums) &#123;</span><br><span class="line">  let pre &#x3D; 0, maxAns &#x3D; nums[0];</span><br><span class="line">  nums.forEach((x) &#x3D;&gt; &#123;</span><br><span class="line">    pre &#x3D; Math.max(pre + x, x);</span><br><span class="line">    maxAns &#x3D; Math.max(maxAns, pre);</span><br><span class="line">  &#125;);</span><br><span class="line">  return maxAns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最后一个单词的长度-–-遍历字符串"><a href="#最后一个单词的长度-–-遍历字符串" class="headerlink" title="最后一个单词的长度 – 遍历字符串"></a>最后一个单词的长度 – 遍历字符串</h4><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p>
<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;string&#125; s</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var lengthOfLastWord &#x3D; function(s) &#123;</span><br><span class="line">  let end &#x3D; s.length - 1</span><br><span class="line">  while(end &gt;&#x3D; 0 &amp;&amp; s[end] &#x3D;&#x3D;&#x3D; &#39; &#39;) end --</span><br><span class="line">  if (end &lt; 0) return 0</span><br><span class="line">  let start &#x3D; end</span><br><span class="line">  while(start &gt;&#x3D; 0 &amp;&amp; s[start] !&#x3D;&#x3D; &#39; &#39;) start --</span><br><span class="line">  return end - start</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="加一-–-数组遍历"><a href="#加一-–-数组遍历" class="headerlink" title="加一 – 数组遍历"></a>加一 – 数组遍历</h4><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; digits</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var plusOne &#x3D; function(digits) &#123;</span><br><span class="line">  const len &#x3D; digits.length;</span><br><span class="line">  for(let i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    digits[i]++;</span><br><span class="line">    digits[i] %&#x3D; 10;</span><br><span class="line">    if(digits[i]!&#x3D;0)</span><br><span class="line">      return digits;</span><br><span class="line">  &#125;</span><br><span class="line">  digits &#x3D; [...Array(len + 1)].map(_&#x3D;&gt;0);;</span><br><span class="line">  digits[0] &#x3D; 1;</span><br><span class="line">  return digits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="x-的平方根-–-二分法"><a href="#x-的平方根-–-二分法" class="headerlink" title="x 的平方根 – 二分法"></a>x 的平方根 – 二分法</h4><p>实现  int sqrt(int x)  函数。</p>
<p>计算并返回  x  的平方根，其中  x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number&#125; x</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var mySqrt &#x3D; function(x) &#123;</span><br><span class="line">  let left &#x3D; 0, right &#x3D; x</span><br><span class="line">  while(left &lt;&#x3D; right) &#123;</span><br><span class="line">    let mid &#x3D; (left + right) &gt;&gt; 1</span><br><span class="line">    if (mid * mid &lt; x) &#123;</span><br><span class="line">      left &#x3D; mid + 1</span><br><span class="line">    &#125; else if (mid * mid &gt; x) &#123;</span><br><span class="line">      right &#x3D; mid - 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return right</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number&#125; n</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var climbStairs &#x3D; function(n) &#123;</span><br><span class="line">  let p &#x3D; 0, q &#x3D; 0, r &#x3D; 1</span><br><span class="line">  for(let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    p &#x3D; q</span><br><span class="line">    q &#x3D; r</span><br><span class="line">    r &#x3D; p + q</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="删除排序链表中的重复元素-–-链表"><a href="#删除排序链表中的重复元素-–-链表" class="headerlink" title="删除排序链表中的重复元素 – 链表"></a>删除排序链表中的重复元素 – 链表</h4><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。</p>
<p>返回同样按升序排列的结果链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* function ListNode(val, next) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;ListNode&#125; head</span><br><span class="line">* @return &#123;ListNode&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var deleteDuplicates &#x3D; function(head) &#123;</span><br><span class="line">  if (!head) return head</span><br><span class="line">  let cur &#x3D; head</span><br><span class="line">  while (cur.next) &#123;</span><br><span class="line">    if (cur.val &#x3D;&#x3D;&#x3D; cur.next.val) &#123;</span><br><span class="line">      cur.next &#x3D; cur.next.next</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cur &#x3D; cur.next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="合并两个有序数组-–-双指针"><a href="#合并两个有序数组-–-双指针" class="headerlink" title="合并两个有序数组 – 双指针"></a>合并两个有序数组 – 双指针</h4><p>给你两个按 非递减顺序 排列的整数数组  nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums1</span><br><span class="line">* @param &#123;number&#125; m</span><br><span class="line">* @param &#123;number[]&#125; nums2</span><br><span class="line">* @param &#123;number&#125; n</span><br><span class="line">* @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span><br><span class="line">*&#x2F;</span><br><span class="line">var merge &#x3D; function(nums1, m, nums2, n) &#123;</span><br><span class="line">  const sorted &#x3D; new Array(m + n).fill(0)</span><br><span class="line">  let p1 &#x3D; 0, p2 &#x3D; 0</span><br><span class="line">  var cur</span><br><span class="line">  while(p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">    if (p1 &#x3D;&#x3D;&#x3D; m) &#123;</span><br><span class="line">      cur &#x3D; nums2[p2++]</span><br><span class="line">    &#125; else if (p2 &#x3D;&#x3D;&#x3D; n) &#123;</span><br><span class="line">      cur &#x3D; nums1[p1++]</span><br><span class="line">    &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">      cur &#x3D; nums1[p1++]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cur &#x3D; nums2[p2++]</span><br><span class="line">    &#125;</span><br><span class="line">    sorted[p1 + p2 - 1] &#x3D; cur</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; m + n; i++) &#123;</span><br><span class="line">    nums1[i] &#x3D; sorted[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的中序遍历-–-递归"><a href="#二叉树的中序遍历-–-递归" class="headerlink" title="二叉树的中序遍历 – 递归"></a>二叉树的中序遍历 – 递归</h4><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<p>二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var inorderTraversal &#x3D; function(root) &#123;</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  this.middleOrder &#x3D; (root) &#x3D;&gt; &#123;</span><br><span class="line">    if (!root) return</span><br><span class="line">    middleOrder(root.left)</span><br><span class="line">    result.push(root.val)</span><br><span class="line">    middleOrder(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">  middleOrder(root)</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的前序遍历-–-递归"><a href="#二叉树的前序遍历-–-递归" class="headerlink" title="二叉树的前序遍历 – 递归"></a>二叉树的前序遍历 – 递归</h4><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var preorderTraversal &#x3D; function(root) &#123;</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  this.preOrder &#x3D; (root) &#x3D;&gt; &#123;</span><br><span class="line">    if (root &#x3D;&#x3D;&#x3D; null) return</span><br><span class="line">    result.push(root.val)</span><br><span class="line">    preOrder(root.left)</span><br><span class="line">    preOrder(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">  preOrder(root)</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的后序遍历-–-递归"><a href="#二叉树的后序遍历-–-递归" class="headerlink" title="二叉树的后序遍历 – 递归"></a>二叉树的后序遍历 – 递归</h4><p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>二叉树的后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;number[]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var postorderTraversal &#x3D; function(root) &#123;</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  this.lastOrder &#x3D; (root) &#x3D;&gt; &#123;</span><br><span class="line">    if (root &#x3D;&#x3D;&#x3D; null) return</span><br><span class="line">    lastOrder(root.left)</span><br><span class="line">    lastOrder(root.right)</span><br><span class="line">    result.push(root.val)</span><br><span class="line">  &#125;</span><br><span class="line">  lastOrder(root)</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="相同的树-–-递归-深度优先遍历"><a href="#相同的树-–-递归-深度优先遍历" class="headerlink" title="相同的树 – 递归(深度优先遍历)"></a>相同的树 – 递归(深度优先遍历)</h4><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; p</span><br><span class="line">* @param &#123;TreeNode&#125; q</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var isSameTree &#x3D; function(p, q) &#123;</span><br><span class="line">  if (p &#x3D;&#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125; else if (p &#x3D;&#x3D;&#x3D; null || q &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else if (p.val !&#x3D;&#x3D; q.val) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="对称二叉树-–-递归"><a href="#对称二叉树-–-递归" class="headerlink" title="对称二叉树 – 递归"></a>对称二叉树 – 递归</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var isSymmetric &#x3D; function(root) &#123;</span><br><span class="line">  return check(root, root)</span><br><span class="line">&#125;;</span><br><span class="line">const check &#x3D; (p, q) &#x3D;&gt; &#123;</span><br><span class="line">  if (!p &amp;&amp; !q) return true</span><br><span class="line">  if (!p || !q) return false</span><br><span class="line">  return p.val &#x3D;&#x3D;&#x3D; q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的最小深度-–-递归"><a href="#二叉树的最小深度-–-递归" class="headerlink" title="二叉树的最小深度 – 递归"></a>二叉树的最小深度 – 递归</h4><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var minDepth &#x3D; function(root) &#123;</span><br><span class="line">  if (!root) return 0</span><br><span class="line">  if (!root.left) return minDepth(root.right) + 1</span><br><span class="line">  if (!root.right) return minDepth(root.left) + 1</span><br><span class="line">  return (Math.min(minDepth(root.left), minDepth(root.right))) + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的最大深度-–-递归"><a href="#二叉树的最大深度-–-递归" class="headerlink" title="二叉树的最大深度 – 递归"></a>二叉树的最大深度 – 递归</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var maxDepth &#x3D; function(root) &#123;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let left &#x3D; maxDepth(root.left)</span><br><span class="line">    let right &#x3D; maxDepth(root.right)</span><br><span class="line">    return Math.max(left, right) + 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将有序数组转换为二叉搜索树-–-递归，二分法"><a href="#将有序数组转换为二叉搜索树-–-递归，二分法" class="headerlink" title="将有序数组转换为二叉搜索树 – 递归，二分法"></a>将有序数组转换为二叉搜索树 – 递归，二分法</h4><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @return &#123;TreeNode&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var sortedArrayToBST &#x3D; function (nums) &#123;</span><br><span class="line">  if (!nums.length) return null;</span><br><span class="line">  const mid &#x3D; nums.length &gt;&gt;&gt; 1;</span><br><span class="line">  let cur &#x3D; new TreeNode(nums[mid]);</span><br><span class="line">  cur.left &#x3D; sortedArrayToBST(nums.slice(0, mid));</span><br><span class="line">  cur.right &#x3D; sortedArrayToBST(nums.slice(mid+1));</span><br><span class="line">  return cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="平衡二叉树-–-递归"><a href="#平衡二叉树-–-递归" class="headerlink" title="平衡二叉树 – 递归"></a>平衡二叉树 – 递归</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var isBalanced &#x3D; function (root) &#123;</span><br><span class="line">if(!root) return true</span><br><span class="line">return Math.abs(depth(root.left) - depth(root.right)) &lt;&#x3D; 1</span><br><span class="line">  &amp;&amp; isBalanced(root.left)</span><br><span class="line">  &amp;&amp; isBalanced(root.right)</span><br><span class="line">&#125;</span><br><span class="line">var depth &#x3D; function (node) &#123;</span><br><span class="line">  if(!node) return -1</span><br><span class="line">  return 1 + Math.max(depth(node.left), depth(node.right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="路径总和-–-递归"><a href="#路径总和-–-递归" class="headerlink" title="路径总和 – 递归"></a>路径总和 – 递归</h4><p>给你二叉树的根节点  root 和一个表示目标和的整数  targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和  targetSum 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for a binary tree node.</span><br><span class="line">* function TreeNode(val, left, right) &#123;</span><br><span class="line">*     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line">*     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line">*     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;TreeNode&#125; root</span><br><span class="line">* @param &#123;number&#125; targetSum</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var hasPathSum &#x3D; function(root, targetSum) &#123;</span><br><span class="line">  if (!root) return false</span><br><span class="line">  if (!root.left &amp;&amp; !root.right) return root.val &#x3D;&#x3D;&#x3D; targetSum</span><br><span class="line">  return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right,   targetSum - root.val)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="杨辉三角-–-数学"><a href="#杨辉三角-–-数学" class="headerlink" title="杨辉三角 – 数学"></a>杨辉三角 – 数学</h4><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number&#125; numRows</span><br><span class="line">* @return &#123;number[][]&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var generate &#x3D; function(numRows) &#123;</span><br><span class="line">  let ret &#x3D; []</span><br><span class="line">  for(let i &#x3D; 0; i &lt; numRows; i++) &#123;</span><br><span class="line">    const row &#x3D; new Array(i + 1).fill(1)</span><br><span class="line">    for (let j &#x3D; 1; j &lt; row.length - 1; j++) &#123;</span><br><span class="line">      row[j] &#x3D; ret[i - 1][j - 1] + ret[i - 1][j]</span><br><span class="line">    &#125;</span><br><span class="line">    ret.push(row)</span><br><span class="line">  &#125;</span><br><span class="line">  return ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="买卖股票的最佳时机-–-遍历"><a href="#买卖股票的最佳时机-–-遍历" class="headerlink" title="买卖股票的最佳时机 – 遍历"></a>买卖股票的最佳时机 – 遍历</h4><p>给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; prices</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var maxProfit &#x3D; function(prices) &#123;</span><br><span class="line">  let res &#x3D; 0</span><br><span class="line">  let buy &#x3D; Number.MAX_VALUE</span><br><span class="line">  for (let price of prices) &#123;</span><br><span class="line">    buy &#x3D; Math.min(buy, price)</span><br><span class="line">    res &#x3D; Math.max(res, price - buy)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="验证回文串-–-双指针"><a href="#验证回文串-–-双指针" class="headerlink" title="验证回文串 – 双指针"></a>验证回文串 – 双指针</h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;string&#125; s</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var isPalindrome &#x3D; function(s) &#123;</span><br><span class="line">  s &#x3D; s.toLowerCase();</span><br><span class="line">  const reg &#x3D; &#x2F;^[0-9a-z]*$&#x2F;;</span><br><span class="line">  let left &#x3D; 0</span><br><span class="line">  let right &#x3D; s.length - 1</span><br><span class="line">  while(left &lt; right) &#123;</span><br><span class="line">    if (!reg.test(s[left])) &#123;</span><br><span class="line">      left++</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    if (!reg.test(s[right])) &#123;</span><br><span class="line">      right--</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    if (s[left] &#x3D;&#x3D;&#x3D; s[right]) &#123;</span><br><span class="line">      left++</span><br><span class="line">      right--</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="只出现一次的数字-–-位运算"><a href="#只出现一次的数字-–-位运算" class="headerlink" title="只出现一次的数字 – 位运算"></a>只出现一次的数字 – 位运算</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var singleNumber &#x3D; function(nums) &#123;</span><br><span class="line">  let a &#x3D; 0</span><br><span class="line">  for (const item of nums) &#123;</span><br><span class="line">    a ^&#x3D; item</span><br><span class="line">  &#125;</span><br><span class="line">  return a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="环形链表-–-哈希-快慢指针"><a href="#环形链表-–-哈希-快慢指针" class="headerlink" title="环形链表 – 哈希/快慢指针"></a>环形链表 – 哈希/快慢指针</h4><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* function ListNode(val) &#123;</span><br><span class="line">*     this.val &#x3D; val;</span><br><span class="line">*     this.next &#x3D; null;</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;ListNode&#125; head</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">  let obj &#x3D; new Map()</span><br><span class="line">  while(head) &#123;</span><br><span class="line">    if (obj.has(head)) return true</span><br><span class="line">    obj.set(head, true)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* function ListNode(val) &#123;</span><br><span class="line">*     this.val &#x3D; val;</span><br><span class="line">*     this.next &#x3D; null;</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;ListNode&#125; head</span><br><span class="line">* @return &#123;boolean&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">  let fast &#x3D; head</span><br><span class="line">  let slow &#x3D; head</span><br><span class="line">  while(fast) &#123;</span><br><span class="line">    if (fast.next &#x3D;&#x3D;&#x3D; null) return false</span><br><span class="line">    slow &#x3D; slow.next</span><br><span class="line">    fast &#x3D; fast.next.next</span><br><span class="line">    if (slow &#x3D;&#x3D;&#x3D; fast) return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="相交链表-–-双指针"><a href="#相交链表-–-双指针" class="headerlink" title="相交链表 – 双指针"></a>相交链表 – 双指针</h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* function ListNode(val) &#123;</span><br><span class="line">*     this.val &#x3D; val;</span><br><span class="line">*     this.next &#x3D; null;</span><br><span class="line">* &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;ListNode&#125; headA</span><br><span class="line">* @param &#123;ListNode&#125; headB</span><br><span class="line">* @return &#123;ListNode&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">  if(headA &#x3D;&#x3D;&#x3D; null || headB &#x3D;&#x3D;&#x3D; null) return null</span><br><span class="line">  let pA &#x3D; headA, pB &#x3D; headB</span><br><span class="line">  while(pA !&#x3D;&#x3D; pB) &#123;</span><br><span class="line">    pA &#x3D; pA &#x3D;&#x3D;&#x3D; null ? headB : pA.next</span><br><span class="line">    pB &#x3D; pB &#x3D;&#x3D;&#x3D; null ? headA : pB.next</span><br><span class="line">  &#125;</span><br><span class="line">  return pA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="多数元素-–-哈希-排序"><a href="#多数元素-–-哈希-排序" class="headerlink" title="多数元素 – 哈希/排序"></a>多数元素 – 哈希/排序</h4><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于  ⌊ n/2 ⌋  的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var majorityElement &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  const map &#x3D; new Map();</span><br><span class="line"></span><br><span class="line">  for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    map.set(nums[i], map.has(nums[i]) ? map.get(nums[i]) + 1 : 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (let [key, val] of map) &#123;</span><br><span class="line">    if (val &gt; n &#x2F; 2) &#123;</span><br><span class="line">      return key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; nums</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var majorityElement &#x3D; function(nums) &#123;</span><br><span class="line">  nums.sort()</span><br><span class="line">  return nums[parseInt(nums.length &#x2F; 2)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a>阶乘后的零</h4><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number&#125; n</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var trailingZeroes &#x3D; function(n) &#123;</span><br><span class="line">  let r &#x3D; 0</span><br><span class="line">  while(n &gt; 1) &#123;</span><br><span class="line">    n &#x3D; parseInt(n &#x2F; 5)</span><br><span class="line">    r +&#x3D; n</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904196706140168">https://juejin.cn/post/6844904196706140168</a></p>

            <br />
            <p class="meta">
                
            </p>
        </div>

        <div class="col-sm-3">
             
<span><b> TL;DR</b></span>
<p>
	Yet another hexo theme.
</p>
<hr />


<span><b> TL;DR 2</b></span>
<p>
	No, not another one :/
</p>
<hr />

 

<span
	><a href="https://twitter.com/hexojs" target="_blank" rel="noopener"
		><b
			><i class="fab fa-twitter-square"></i>
			<i class="fas fa-at"></i>
			hexojs</b
		></a
	></span
>
<br />
<a class="twitter-timeline" data-height="800" data-dnt="true" data-chrome="nofooter transparent noheader noborders " target="_blank" rel="noopener" href="https://twitter.com/hexojs?ref_src=twsrc%5Etfw"></a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


        </div>
    </div>
</div>
<!-- Menu fade on scroll -->
<script>
    var isScrolling;
    var prevScrollpos = window.pageYOffset;
    window.addEventListener(
        'scroll',
        function(event) {
            window.clearTimeout(isScrolling);
            isScrolling = setTimeout(function() {
                var currentScrollPos = window.pageYOffset;
                if (prevScrollpos > currentScrollPos) {
                    $('#navbar').slideDown();
                } else {
                    $('#navbar').slideUp();
                }
                prevScrollpos = currentScrollPos;
            }, 66);
        },
        false
    );
</script>


<a class="float-left gradient btn paginationbtn" href="/2022/04/09/vue/"><i class="fas fa-chevron-left"></i></a>


<a class="float-right gradient btn paginationbtn" href="/2022/04/09/es6/"><i class="fas fa-chevron-right"></i></a>

    </main>
    <!-- Footer -->
    <footer class="page-footer">
  <div class="container">
    <div class="social-icons">
      
      <a href="https://hexo.io/" title="Hexo.io" target="_blank" rel="noopener" class="fas fa-home"></a>
      
      <a href="https://twitter.com/hexojs" title="@hexojs" target="_blank" rel="noopener" class="fab fa-twitter"></a>
      
      <a href="https://github.com/RandomAdversary/Gradient/issues" title="Report issue" target="_blank" rel="noopener" class="fas fa-bug"></a>
      
    </div>
  </div>
</footer>
    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
    crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
    crossorigin="anonymous"></script>
</body>

</html>