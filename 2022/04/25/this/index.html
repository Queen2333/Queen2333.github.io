<html>
<!-- Head tag -->
<head>
  <meta charset="UTF-8">

  
  <title>
    this （摘自波神的书） |
    Majesty&#39;s blog
  </title>
  


  <meta name="description" content="">
  <meta name="author" content="Alex">
  <meta property="og:title" content="this （摘自波神的书）" />
  <meta property="og:description" content="" />
  <meta property='og:site_name' content='Majesty&#39;s blog' />
  <meta property="og:image" content="http://example.com/img/default.jpg" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:description" content="" />
  <meta name="twitter:title" content="this （摘自波神的书）" />

  <meta name="twitter:image" content="http://example.com/img/default.jpg" />

  <script src="https://www.amcharts.com/lib/4/core.js"></script>
  <script src="https://www.amcharts.com/lib/4/charts.js"></script>
  <script src="https://www.amcharts.com/lib/4/themes/animated.js"></script>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz"
    crossorigin="anonymous">
  
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 5.3.0"></head>

<body>
    <!-- Menu -->
    <nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark page-navbar gradient">
  <div class="container">
    <a class="navbar-brand logo" href="http://example.com">
      Majesty&#39;s blog</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav"
      aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav mx-auto">
        <li class="nav-item item">
          
        <li class="nav-item item">
          <a class="nav-link" href="/">
            Home</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" href="/archives">
            🗂️Archives</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" target="_blank" rel="noopener" href="https://hexo.io/">
            Hexo</a>
        </li>
        
        </li>
      </ul>
    </div>
  </div>
</nav>

    <main class="page main-page">
        <div class="container blogPost">
    <div class="row">
        <div class="col-sm-9 px-md-5">
            <h2 class="blog-post-title">
                this （摘自波神的书）
            </h2>
            <p class="meta">
                <i class="far fa-clock"></i>
                2022-04-25 
            </p>
            <!-- Content -->
            <h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。</p>
<p>危害比较大的是，有的不准确的结论在网上还广为流传。</p>
<p>比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我非常相信这句话。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。</p>
<p>其实只是因为我的认知中有一个不准确的结论。</p>
<p>所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。</p>
<p>在这之前，我们回顾一下执行上下文。</p>
<p>在前面几篇文章中，我有好几个地方都提到执行上下文的生命周期，为了防止大家没有记住，再发一次，如下图。</p>
<p><img src="/images/article/this1.png" alt="this1"></p>
<p>执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经明白了。本文的关键，就是确定this指向。</p>
<p>首先，我们需要得出一个非常重要的，并且一定要牢记于心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</p>
<p>因此，一个函数中的this指向，可以非常灵活。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 10;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); &#x2F;&#x2F; 10</span><br><span class="line">fn.call(obj); &#x2F;&#x2F; 20</span><br><span class="line">除此之外，在函数执行过程中，this一旦被确定，就不可更改了。</span><br><span class="line"></span><br><span class="line">var a &#x3D; 10;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">this &#x3D; obj; &#x2F;&#x2F; 这句话试图修改this，运行后会报错</span><br><span class="line">console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<h5 id="一、全局对象中的this"><a href="#一、全局对象中的this" class="headerlink" title="一、全局对象中的this"></a>一、全局对象中的this</h5><p>关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过this绑定到全局对象</span><br><span class="line">this.a2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><br><span class="line">var a1 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span><br><span class="line">a3 &#x3D; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果会全部符合预期</span><br><span class="line">console.log(a1);</span><br><span class="line">console.log(a2);</span><br><span class="line">console.log(a3);</span><br></pre></td></tr></table></figure>
<h5 id="二、函数中的this"><a href="#二、函数中的this" class="headerlink" title="二、函数中的this"></a>二、函数中的this</h5><p>在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; demo01</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">&#x2F;&#x2F; demo02</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">&#x2F;&#x2F; demo03</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 10,</span><br><span class="line">c: this.a + 20,</span><br><span class="line">fn: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.c);</span><br><span class="line">console.log(obj.fn());</span><br></pre></td></tr></table></figure>
<p>这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。</p>
<p>分析之前，我们直接了当抛出结论。</p>
<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>
<p>从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用十分关键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span><br><span class="line">function fn() &#123;</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  &#x2F;&#x2F; fn是调用者，独立调用</span><br><span class="line">window.fn();  &#x2F;&#x2F; fn是调用者，被window所拥有</span><br></pre></td></tr></table></figure>
<p>在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。</p>
<p>掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。</p>
<p>但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算。这里我们需要明确的一点是，单独的{}不会形成新的作用域，因此这里的this.a，由于并没有作用域的限制，它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。</p>
<p>那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">function foo() &#123;</span><br><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    c: this.a + 20,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return obj.c;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo());    &#x2F;&#x2F; ？</span><br><span class="line">console.log(window.foo());  &#x2F;&#x2F; ?</span><br></pre></td></tr></table></figure>
<p>实际开发中，并不推荐这样使用this；</p>
<p>上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。</p>
<p>再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">a: 10,</span><br><span class="line">getA: function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA()); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">var test &#x3D; foo.getA;</span><br><span class="line">console.log(test());  &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>
<p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>
<p>稍微修改一下代码，大家自行理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">function getA() &#123;</span><br><span class="line">return this.a;</span><br><span class="line">&#125;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">a: 10,</span><br><span class="line">getA: getA</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA());  &#x2F;&#x2F; 10</span><br><span class="line">灵机一动，再来一个。如下例子。</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function active(fn) &#123;</span><br><span class="line">fn(); &#x2F;&#x2F; 真实调用者，为独立调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; 20;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 10,</span><br><span class="line">getA: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">active(obj.getA);</span><br></pre></td></tr></table></figure>
<h5 id="三、使用call，apply显示指定this"><a href="#三、使用call，apply显示指定this" class="headerlink" title="三、使用call，apply显示指定this"></a>三、使用call，apply显示指定this</h5><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有这两个方法。它们除了参数略有不同之外，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>
<p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(num1, num2) &#123;</span><br><span class="line">console.log(this.a + num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj, 100, 10); &#x2F;&#x2F; 130</span><br><span class="line">fn.apply(obj, [20, 10]); &#x2F;&#x2F; 50</span><br></pre></td></tr></table></figure>
<p>因为call/apply的存在，JavaScript变得更加灵活。 也因此他们的使用场景就多种多样。简单总结几点，也欢迎大家补充。</p>
<h5 id="将类数组对象转换为数组"><a href="#将类数组对象转换为数组" class="headerlink" title="将类数组对象转换为数组"></a>将类数组对象转换为数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function exam(a, b, c, d, e) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先看看函数的自带属性 arguments 什么是样子的</span><br><span class="line">console.log(arguments);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用call&#x2F;apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变</span><br><span class="line">var arg &#x3D; [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">console.log(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exam(2, 8, 9, 10, 3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; result:</span><br><span class="line">&#x2F;&#x2F; &#123; &#39;0&#39;: 2, &#39;1&#39;: 8, &#39;2&#39;: 9, &#39;3&#39;: 10, &#39;4&#39;: 3 &#125;</span><br><span class="line">&#x2F;&#x2F; [ 2, 8, 9, 10, 3 ]</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 也常常使用该方法将DOM中的nodelist转换为数组</span><br><span class="line">&#x2F;&#x2F; [].slice.call( document.getElementsByTagName(&#39;li&#39;) );</span><br></pre></td></tr></table></figure>
<h5 id="根据自己的需要灵活修改this指向"><a href="#根据自己的需要灵活修改this指向" class="headerlink" title="根据自己的需要灵活修改this指向"></a>根据自己的需要灵活修改this指向</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">name: &#39;joker&#39;,</span><br><span class="line">showName: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; &#123;</span><br><span class="line">    name: &#39;rose&#39;</span><br><span class="line">&#125;</span><br><span class="line">foo.showName.call(bar);</span><br></pre></td></tr></table></figure>
<h5 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义父级的构造函数</span><br><span class="line">var Person &#x3D; function (name, age) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.gender &#x3D; [&#39;man&#39;, &#39;woman&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子类的构造函数</span><br><span class="line">var Student &#x3D; function (name, age, high) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use call</span><br><span class="line">Person.call(this, name, age);</span><br><span class="line">this.high &#x3D; high;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message &#x3D; function () &#123;</span><br><span class="line">console.log(&#39;name:&#39; + this.name + &#39;, age:&#39; + this.age + &#39;, high:&#39; + this.high + &#39;, gender:&#39; + this.gender[0] + &#39;;&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Student(&#39;xiaom&#39;, 12, &#39;150cm&#39;).message();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; result</span><br><span class="line">&#x2F;&#x2F; ----------</span><br><span class="line">&#x2F;&#x2F; name:xiaom, age:12, high:150cm, gender:man;</span><br></pre></td></tr></table></figure>
<p>简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Student &#x3D; function (name, age, high) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.gender &#x3D; [&#39;man&#39;, &#39;woman&#39;];</span><br><span class="line">&#x2F;&#x2F; Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承</span><br><span class="line">this.high &#x3D; high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在向其他执行上下文的传递中，确保this的指向保持不变</p>
<p>如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20,</span><br><span class="line">getA: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>
<p>常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20,</span><br><span class="line">getA: function () &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">    console.log(self.a)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外就是借助闭包与apply方法，封装一个bind方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">    return fn.apply(obj, arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20,</span><br><span class="line">getA: function () &#123;</span><br><span class="line">    setTimeout(bind(function () &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">    &#125;, this), 1000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">a: 20,</span><br><span class="line">getA: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">    &#125;.bind(this), 1000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6中也常常使用箭头函数的方式来替代这种方案</p>
<h5 id="四、构造函数与原型方法上的this"><a href="#四、构造函数与原型方法上的this" class="headerlink" title="四、构造函数与原型方法上的this"></a>四、构造函数与原型方法上的this</h5><p>在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解到了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。</p>
<p>结合下面的例子，我抛出几个问题大家思考一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的this指向了谁?</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的this又指向了谁？</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面的2个this，是同一个吗，他们是否指向了原型对象？</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; new Person(&#39;Nick&#39;, 20);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure>
<p>我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。</p>
<p>通过new操作符调用构造函数，会经历以下4个阶段。</p>
<p>•创建一个新的对象；<br>•将构造函数的this指向这个新对象；<br>•指向构造函数的代码，为这个对象添加属性，方法等；<br>•返回新对象。</p>
<p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象：p1。</p>
<p>而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。</p>
<p>好啦，我所知道的，关于this的一切，已经总结完了，希望大家在阅读之后，能够真正学到东西，然后给我点个赞！</p>

            <br />
            <p class="meta">
                
            </p>
        </div>

        <div class="col-sm-3">
             
<span><b> TL;DR</b></span>
<p>
	Yet another hexo theme.
</p>
<hr />


<span><b> TL;DR 2</b></span>
<p>
	No, not another one :/
</p>
<hr />

 

<span
	><a href="https://twitter.com/hexojs" target="_blank" rel="noopener"
		><b
			><i class="fab fa-twitter-square"></i>
			<i class="fas fa-at"></i>
			hexojs</b
		></a
	></span
>
<br />
<a class="twitter-timeline" data-height="800" data-dnt="true" data-chrome="nofooter transparent noheader noborders " target="_blank" rel="noopener" href="https://twitter.com/hexojs?ref_src=twsrc%5Etfw"></a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


        </div>
    </div>
</div>
<!-- Menu fade on scroll -->
<script>
    var isScrolling;
    var prevScrollpos = window.pageYOffset;
    window.addEventListener(
        'scroll',
        function(event) {
            window.clearTimeout(isScrolling);
            isScrolling = setTimeout(function() {
                var currentScrollPos = window.pageYOffset;
                if (prevScrollpos > currentScrollPos) {
                    $('#navbar').slideDown();
                } else {
                    $('#navbar').slideUp();
                }
                prevScrollpos = currentScrollPos;
            }, 66);
        },
        false
    );
</script>


<a class="float-left gradient btn paginationbtn" href="/2022/04/25/closure/"><i class="fas fa-chevron-left"></i></a>


<a class="float-right gradient btn paginationbtn" href="/2022/04/28/function/"><i class="fas fa-chevron-right"></i></a>

    </main>
    <!-- Footer -->
    <footer class="page-footer">
  <div class="container">
    <div class="social-icons">
      
      <a href="https://hexo.io/" title="Hexo.io" target="_blank" rel="noopener" class="fas fa-home"></a>
      
      <a href="https://twitter.com/hexojs" title="@hexojs" target="_blank" rel="noopener" class="fab fa-twitter"></a>
      
      <a href="https://github.com/RandomAdversary/Gradient/issues" title="Report issue" target="_blank" rel="noopener" class="fas fa-bug"></a>
      
    </div>
  </div>
</footer>
    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
    crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
    crossorigin="anonymous"></script>
</body>

</html>