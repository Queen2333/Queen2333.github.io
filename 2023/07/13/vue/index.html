<html>
<!-- Head tag -->
<head>
  <meta charset="UTF-8">

  
  <title>
    前端架构--Vue综合知识点 |
    Majesty&#39;s blog
  </title>
  


  <meta name="description" content="">
  <meta name="author" content="Alex">
  <meta property="og:title" content="前端架构--Vue综合知识点" />
  <meta property="og:description" content="" />
  <meta property='og:site_name' content='Majesty&#39;s blog' />
  <meta property="og:image" content="http://example.com/img/default.jpg" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:description" content="" />
  <meta name="twitter:title" content="前端架构--Vue综合知识点" />

  <meta name="twitter:image" content="http://example.com/img/default.jpg" />

  <script src="https://www.amcharts.com/lib/4/core.js"></script>
  <script src="https://www.amcharts.com/lib/4/charts.js"></script>
  <script src="https://www.amcharts.com/lib/4/themes/animated.js"></script>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz"
    crossorigin="anonymous">
  
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <!-- Menu -->
    <nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark page-navbar gradient">
  <div class="container">
    <a class="navbar-brand logo" href="http://example.com">
      Majesty&#39;s blog</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav"
      aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav mx-auto">
        <li class="nav-item item">
          
        <li class="nav-item item">
          <a class="nav-link" href="/">
            Home</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" href="/archives">
            🗂️Archives</a>
        </li>
        
        <li class="nav-item item">
          <a class="nav-link" target="_blank" rel="noopener" href="https://hexo.io/">
            Hexo</a>
        </li>
        
        </li>
      </ul>
    </div>
  </div>
</nav>

    <main class="page main-page">
        <div class="container blogPost">
    <div class="row">
        <div class="col-sm-9 px-md-5">
            <h2 class="blog-post-title">
                前端架构--Vue综合知识点
            </h2>
            <p class="meta">
                <i class="far fa-clock"></i>
                2023-07-13 
            </p>
            <!-- Content -->
            <h4 id="Vue-中组件之间的通信"><a href="#Vue-中组件之间的通信" class="headerlink" title="Vue 中组件之间的通信"></a>Vue 中组件之间的通信</h4><p>阐述过程（1.分几类；2.使用；3.选用）</p>
<p>方法：</p>
<p>1.props(父子组件简单数据传递)</p>
<p>2.$emit/$on 事件总线</p>
<p>3.vuex(需要保存状态)</p>
<p>4.$parent/$children</p>
<p>5.$attrs/$listeners/$root</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kratial/article/details/108825249">https://blog.csdn.net/Kratial/article/details/108825249</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qdcainiao/article/details/119741534">https://blog.csdn.net/qdcainiao/article/details/119741534</a></p>
<p>6.provide/inject</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yw00yw/article/details/107341934">https://blog.csdn.net/yw00yw/article/details/107341934</a></p>
<p>分三类</p>
<p>1.父子组件通信</p>
<p>2.兄弟组件通信</p>
<p>3.跨层组件通信</p>
<hr>
<h4 id="父组件调用子组件的方法"><a href="#父组件调用子组件的方法" class="headerlink" title="父组件调用子组件的方法"></a>父组件调用子组件的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.child.func()</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Vue-的性能优化方法"><a href="#Vue-的性能优化方法" class="headerlink" title="Vue 的性能优化方法"></a>Vue 的性能优化方法</h4><p>1.路由懒加载import</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new vueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: &#39;&#x2F;foo&#39;, component:() &#x3D;&gt; import(&#39;.&#x2F;Foo.vue&#39;)&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.keep-alive 缓存页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;keep-alive&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>3.使用 v-show 复用 DOM</p>
<p>4.v-for 遍历避免同时使用 v-if(选项有判断直接放在计算属性)</p>
<p>5.长列表性能优化<br>.纯数据展示，不会有任何变化，就不需要做响应化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data: () &#x3D;&gt; (&#123;</span><br><span class="line">        users: []</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async created() &#123;</span><br><span class="line">    const users &#x3D; await axios.get(&quot;&#x2F;api&#x2F;users&quot;);</span><br><span class="line">    this.users &#x3D; object.freeze(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;recycle-scroller class&#x3D;&quot;items&quot; :items&#x3D;&quot;items&quot; :item-size&#x3D;&quot;24&quot;&gt;</span><br><span class="line">    &lt;template v-slot&#x3D;&quot;&#123;item&#125;&quot;&gt;</span><br><span class="line">        &lt;FetchItemView :item&#x3D;&quot;item&quot; @vote&#x3D;&quot;voteItem(item)&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;recycle-scroller&gt;</span><br></pre></td></tr></table></figure>

<p>分页：分批加载和渲染数据。<br>懒加载：对图片和多媒体内容使用懒加载技术。<br>组件分片渲染：利用 requestAnimationFrame 等机制。</p>
<p>6.事件的销毁</p>
<p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但仅限于组件本身的事件,和组件关系不大则需要手动在 beforeDestory 清除</p>
<p>7.图片懒加载</p>
<p>页面内未出现在可视区域内的图片先不做加载，滚动到可视区域后再加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-lazy&#x3D;&quot;&#x2F;static&#x2F;img&#x2F;1.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>8.第三方插件按需引入</p>
<p>9.无状态的组件标记为函数式组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tempalte functional&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div v-if&#x3D;&quot;props.value&quot; class&#x3D;&quot;on&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;section v-else class&#x3D;&quot;off&quot;&gt;&lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#39;value&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>10.子组件分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;childComp&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        childComp: &#123;</span><br><span class="line">            methods: &#123;</span><br><span class="line">                heavy () &#123; &#x2F;*耗时任务*&#x2F;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            render (h) &#123;</span><br><span class="line">                return h(&#39;div&#39;, this.heavy())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>11.变量本地化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; result &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; heavy &#125; from &#39;@&#x2F;utils</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#39;start&#39;],</span><br><span class="line">    computed: &#123;</span><br><span class="line">        base () &#123; return 42 &#125;,</span><br><span class="line">        result () &#123;</span><br><span class="line">            const base &#x3D; this.base &#x2F;&#x2F; 不要频繁引用this.base</span><br><span class="line">            let result &#x3D; this.start</span><br><span class="line">            for (let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                result +&#x3D; heavy(base)</span><br><span class="line">            &#125;</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>12.SSR</p>
<pre><code>SSR是服务端渲染：在后台将vue实例渲染为HTML字符串直接返回，在前端激活为交互程序。

实现原理：

客户端发送请求给服务器
服务器查询数据库，使用视图、模板引擎等拼接成html字符串，返回给客户端
客户端渲染html
优点：

网页内容在服务器端渲染完成，一次性传输到浏览器，所以首屏加载速度非常快
有利于SEO，因为服务器返回的是一个完整的html，在浏览器可以看到完整的dom，对于爬虫、百度搜索等引擎就比较友好
缺点：

在后续跳转其它链接时，整个页面还要重复这样的操作，不断地请求响应、请求响应，相对来说，消耗的带宽资源、后续请求的时间就多了，对服务器造成过多负担。</code></pre>
<hr>
<h4 id="Vue-监听数据的三种方法"><a href="#Vue-监听数据的三种方法" class="headerlink" title="Vue 监听数据的三种方法"></a>Vue 监听数据的三种方法</h4><p>1.在 input 标签里绑定 keyup 事件</p>
<p>2.watch 监听数据变化:监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数，<br>该方法可以不用绑定事件;</p>
<p>watch 监听路由变化:<br><code>watch: &#123; &#39;$route.path&#39;: function (newVal, oldVal) &#123; ... &#125; &#125;</code></p>
<p>3.computed 计算属性的使用</p>
<hr>
<h4 id="computed、watch、methods-对比"><a href="#computed、watch、methods-对比" class="headerlink" title="computed、watch、methods 对比"></a>computed、watch、methods 对比</h4><p>1.computed 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p>
<pre><code>主要当作属 性来使用;(注:在引用的时候，一定不要加 () 去调用，直接把它当作普通 属性去使用 就好了;
只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变 化，就会立即重新计算这个
计算属性的值;计算属性的求值结果，会被缓存起来，方便 下次直接使用; 如果 计算属性方法中，所有的任
何数据，都没有发生过变化，则不会重 新对计算属性求值;)适合对于任何复杂逻辑或一个数据属性在它所依赖
的属性发生变化时，也要发生变化，即一个属性受多个属性影响时使用。</code></pre>
<p>2.methods 方法表示一个具体的操作，主要书写业务逻辑;</p>
<p>3.watch 一个对象，键是需要观察的表达式，值是对应回调函数。</p>
<pre><code>主要用来监听某些特定数 据的变化，从而进行某些具体的业务逻辑操作;可以看作是 computed 和 methods
的结合体。需要在数据变化时执行异步或开销较大的操作时使用，即当一条数据影响多条数据的时候。</code></pre>
<hr>
<h4 id="Vue-拓展某现有组件"><a href="#Vue-拓展某现有组件" class="headerlink" title="Vue 拓展某现有组件"></a>Vue 拓展某现有组件</h4><p>1.使用 Vue.mixin 全局混入</p>
<pre><code>mixin的调用顺序：混入对象的钩子将在组件自身钩子之前调用，如果遇到全局混入（Vue.mixin），全局混入
的执行顺序要先于混入和组件里的方法</code></pre>
<p>2.加 slot 拓展</p>
<pre><code>默认插槽和匿名插槽：slot用来获取组件中的原内容

具名插槽</code></pre>
<hr>
<h4 id="Vue-router-导航钩子"><a href="#Vue-router-导航钩子" class="headerlink" title="Vue-router 导航钩子"></a>Vue-router 导航钩子</h4><p>1.全局导航钩子</p>
<p>beforeEach(to, from, next)：路由改变前调用</p>
<pre><code>常用验证用户权限

to: 即将要进入的目标路由对象;

from: 当前导航即将要离开的路由对象;

next: 路由控制参数

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next() &#x2F;&#x2F; 如一切正常，调用此方法进入下一个钩子</span><br><span class="line">next(false) &#x2F;&#x2F; 取消导航</span><br><span class="line">next(&#39;route&#39;) &#x2F;&#x2F; 当前导航被中断，然后进行一个新导航</span><br><span class="line">next(&#39;error&#39;) &#x2F;&#x2F; 如果一个error实例，则导航会被终止且该错误会被传递给router.onError()</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<p>afterEach(to, from): 路由改变后的钩子</p>
<pre><code>常用自动让页面返回最顶端

用法相似，少了next参数</code></pre>
<p>2.路由配置中导航钩子</p>
<p>beforeEnter(to, from, next)</p>
<pre><code>用法同上</code></pre>
<p>3.组件内部导航钩子</p>
<p>beforeRouteEnter(to, from, next)</p>
<pre><code>该组件的对应路由被comfirm前调用

此时实例未被创建，所以不能获取实例(this)</code></pre>
<p>beforeRouteUpdate(to, from, next)</p>
<pre><code>当前路由改变，但该组件被复用时调用

该组件内可以访问实例(this)</code></pre>
<p>beforeRouteLeave(to, from, next)</p>
<pre><code>当导航离开组件的对应路由时调用

该组件内可以访问实例(this)</code></pre>
<p>4.路由监测变化</p>
<p>watch 监听$router 对象</p>
<hr>
<h4 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h4><p>组件可以在他们自己模板中调用自身</p>
<p>一定要有一个结束的条件，可使用 v-if=”false”作为递归组件的结束条件。用到递归组件，数据格式是需要<br>满足的如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">                &lt;tree-menu :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            treeMenu</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: &#39;全栈工程师&#39;,</span><br><span class="line">                        cList: [</span><br><span class="line">                            &#123;name: &#39;vue&#39;&#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                name: &#39;react&#39;,</span><br><span class="line">                                cList: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        name: &#39;js&#39;,</span><br><span class="line">                                        cList: [&#123;name: &#39;css&#39;&#125;]</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;name: &#39;高级工程师&#39;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Vue-必会-api"><a href="#Vue-必会-api" class="headerlink" title="Vue 必会 api"></a>Vue 必会 api</h4><p>1.数据相关</p>
<pre><code>Vue.set(vm.$set): 向响应式对象中追加属性，并希望这个属性也是响应式，且触发视图更新

Vue.delete(vm.$delete): 删除对象的属性，对象如是响应式的，能确保触发试图更新</code></pre>
<p>2.事件相关</p>
<pre><code>vm.$on: 监听当前实例上的自定义事件，可由vm.$emit触发。回调函数接收所有传入事件的参数
并非在子组件派发，在父组件接受，父子组件为同一实例。
转换成代码形式如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(&#39;test&#39;, function(msg) &#123;</span><br><span class="line">    console.log(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

vm.$emit: 触发当前实例上的事件，附加参数会传给监听器回调

典型应用：事件总线

    通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信，且不受组件关系的
    影响。（Vue.prototype.$bus = new Vue()）</code></pre>
<p>3.节点引用</p>
<pre><code>ref和vm.$refs：ref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对
象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件

注意：ref是作为渲染结果被创建的，在初始渲染时不能访问（至少在mounted之后访问）；$refs
不是响应式的，不要试图用它在模板中做数据绑定；当v-for用于元素或组件时，引用信息将是包含
DOM节点或组件实例的数组</code></pre>
<hr>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><pre><code>1.css过度和动画中自动应用class
2.配合使用第三方css动画库，如animate.css
3.在过渡钩子函数中使用js直接操作dom
4.配合使用第三方js动画库，如velocity.js
5.列表过度利用trasition-group可以对v-for渲染每个元素应用过度
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group name&#x3D;&quot;fade&quot;&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;c in coures&quot; :key&#x3D;&quot;c.name&quot;&gt;</span><br><span class="line">        &#123;&#123;c.name&#125;&#125; - $&#123;&#123;c.price&#125;&#125;</span><br><span class="line">        &lt;button @click&#x3D;&quot;addToCart(c)&quot;&gt;加购&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;transition-group&gt;</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><pre><code>可用于对传入的文本进行格式化：双花括号插值和v-bind表达式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 双花括号 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-bind --&gt;</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">filters: &#123;</span><br><span class="line">    capitalize(value, symbol &#x3D; &#39;¥&#39;) &#123;</span><br><span class="line">        return symbol + value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><pre><code>有复用的功能，并且需要操作dom元素时可使用自定义指令

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&#39;permission&#39;, &#123;</span><br><span class="line">    inserted(el, binding) &#123;</span><br><span class="line">        console.log(binding)</span><br><span class="line">        if (role !&#x3D;&#x3D; binding.value) &#123;</span><br><span class="line">            el.parentElement.removeChild()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;button v-permission&#x3D;&quot;&#39;admin&#39;&quot;&gt;</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h4 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h4><p>Vue 推荐在绝大多数情况下使用模板创建 html，但在一些场景下需要用 js 的完全编程能力，此时需要用到渲染函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render: function (createElement) &#123;</span><br><span class="line">  &#x2F;&#x2F; createElement函数返回的是VNode</span><br><span class="line">  return &#123;</span><br><span class="line">    tag, &#x2F;&#x2F; 标签名称 &#123;String | Object | Function&#125; 或者resolve上述任何一种async函数</span><br><span class="line">    data, &#x2F;&#x2F; 传递数据</span><br><span class="line">    children &#x2F;&#x2F; 子节点数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;heading :level&#x3D;&quot;1&quot; :title&#x3D;&quot;title&quot; icon&#x3D;&quot;cart&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;heading&gt;</span><br><span class="line">&lt;h2 title&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;svg class&#x3D;&quot;icon&quot;&gt;</span><br><span class="line">    &lt;use xlink:href&#x3D;&quot;#icon-cart&quot;&gt;&lt;&#x2F;use&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br><span class="line">&lt;&#x2F;h2&gt; &#x2F;&#x2F;插值</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;heading&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    icon: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render(h) &#123; &#x2F;&#x2F; h就是createElement</span><br><span class="line">    &#x2F;&#x2F; 子节点数组</span><br><span class="line">    let children &#x3D; []</span><br><span class="line">    &#x2F;&#x2F; icon属性处理逻辑</span><br><span class="line">    if (this.icon) &#123;</span><br><span class="line">      &#x2F;&#x2F; &lt;svg class&#x3D;&quot;icon&quot;&gt;&lt;use xlink&#x3D;&quot;#icon-cart&quot;&gt;&lt;&#x2F;use&gt;&lt;&#x2F;svg&gt;</span><br><span class="line">      children.push(h(</span><br><span class="line">        &#39;svg&#39;,</span><br><span class="line">        &#123;class: &#39;icon&#39;&#125;,</span><br><span class="line">        [h(&#39;use&#39;, &#123;attrs: &#123;&#39;xlink:href&#39;: &#39;#icon-&#39; + this.icon&#125;&#125;)]</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拼接子节点</span><br><span class="line">    children &#x3D; children.concat(this.$slots.default)</span><br><span class="line">    &#x2F;&#x2F; snabbdom</span><br><span class="line">    const vnode &#x3D; h( &#x2F;&#x2F; 必须返回</span><br><span class="line">      &#39;h&#39; + this.level, &#x2F;&#x2F; 参数1:tagname</span><br><span class="line">      &#123;attrs: &#123;title: this.title&#125;&#125;, &#x2F;&#x2F;参数2: &#123;...&#125;</span><br><span class="line">      children, &#x2F;&#x2F;参数3:子节点VNode数组</span><br><span class="line">    )</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>组件没有任何管理状态，也没有监听任何传递给他的状态，也没有生命周期方法时，可以将组件标记为 functional，<br>这意味着它无状态（没有响应式数据），也没有实例（没有 this 上下文）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;heading&#39;,&#123;</span><br><span class="line">  functional: true, &#x2F;&#x2F; 函数式组件</span><br><span class="line">  props: &#123;...&#125;,</span><br><span class="line">  render(h, context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 子节点数组</span><br><span class="line">    let children &#x3D; []</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 属性获取</span><br><span class="line">    const &#123;icon, title, level&#125; &#x3D; context.props</span><br><span class="line">    &#x2F;&#x2F; icon属性处理逻辑</span><br><span class="line">    if (icon) &#123;</span><br><span class="line">      &#x2F;&#x2F; &lt;svg class&#x3D;&quot;icon&quot;&gt;&lt;use xlink&#x3D;&quot;#icon-cart&quot;&gt;&lt;&#x2F;use&gt;&lt;&#x2F;svg&gt;</span><br><span class="line">      children.push(h(</span><br><span class="line">        &#39;svg&#39;,</span><br><span class="line">        &#123;class: &#39;icon&#39;&#125;,</span><br><span class="line">        [h(&#39;use&#39;, &#123;attrs: &#123;&#39;xlink:href&#39;: &#39;#icon-&#39; + icon&#125;&#125;)]</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拼接子节点</span><br><span class="line">    children &#x3D; children.concat(context.children)</span><br><span class="line">    &#x2F;&#x2F; snabbdom</span><br><span class="line">    const vnode &#x3D; h( &#x2F;&#x2F; 必须返回</span><br><span class="line">      &#39;h&#39; + level, &#x2F;&#x2F; 参数1:tagname</span><br><span class="line">      &#123;attrs: &#123;title&#125;&#125;, &#x2F;&#x2F;参数2: &#123;...&#125;</span><br><span class="line">      children, &#x2F;&#x2F;参数3:子节点VNode数组</span><br><span class="line">    )</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入 mixin"></a>混入 mixin</h4><p>提供了一种非常灵活的方式，来分发 vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入<br>对象时，所有混入对象的选项将被“混合”进入该组件本身的选项（选项合并组件中的值优先级高，生命周期都保留）</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个混入对象</span><br><span class="line">var myMixin &#x3D; &#123;</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    this.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: function () &#123;</span><br><span class="line">      console.log(&#39;hello from mixin!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;comp&#39;, &#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>用于为 Vue 添加全局功能范围如下：</p>
<pre><code>1.添加全局方法或属性，如：vue-custom-element

2.添加全局资源：指令/过滤器/过渡等，如：vue-touch

3.通过全局混入来添加一些组件选项，如：vue-router

4.添加Vue实例方法，通过把他们添加到Vue.prototype上实现

5.一个库，提供自己的Api，同时提供上面提到的一个或多个功能，如：vue-router</code></pre>
<h5 id="插件声明"><a href="#插件声明" class="headerlink" title="插件声明"></a>插件声明</h5><pre><code>Vue的插件应该暴露一个install方法，这个方法的第一个参数是Vue构造器第二个参数是一个可选的选项对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install &#x3D; function(Vue, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 1.添加全局方法成属性</span><br><span class="line">  Vue.myGlobalMethod &#x3D; function () &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 2.添加全局资源</span><br><span class="line">  Vue.directive(&#39;my-directive&#39;, &#123;&#125;)</span><br><span class="line">  &#x2F;&#x2F; 3.注入组件选项</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: function() &#123;</span><br><span class="line">      &#x2F;&#x2F; ...逻辑</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 4.添加实例方法</span><br><span class="line">  Vue.prototype.$myMethod &#x3D; function (methodOptions) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插件需要实现</span><br><span class="line">const MyPlugin &#x3D; &#123;</span><br><span class="line">  install(Vue, options) &#123;</span><br><span class="line">    Vye.component(&#39;heading&#39;, &#123;</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(typeof window !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  &#x2F;&#x2F;使用插件使用Vue.use()</span><br><span class="line">  window.Vue.use(MyPlugin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;plugins&#x2F;heading.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h4 id="v-if-和-v-for-的优先级"><a href="#v-if-和-v-for-的优先级" class="headerlink" title="v-if 和 v-for 的优先级"></a>v-if 和 v-for 的优先级</h4><p>1.v-for 优先于 v-if</p>
<p>2.如果同时出现，每次都会先执行循环再条件判断，浪费性能</p>
<p>3.避免方法可在外层嵌套 template，在这一层进行 v-if</p>
<p>4.如果循环内部子元素有相应判断条件，应该使用计算属性过滤出要展示的元素来进行优化，而不是使用 v-if</p>
<hr>
<h4 id="Vue-组件-data-为什么必须是函数，而-Vue-的根实例没有此限制"><a href="#Vue-组件-data-为什么必须是函数，而-Vue-的根实例没有此限制" class="headerlink" title="Vue 组件 data 为什么必须是函数，而 Vue 的根实例没有此限制"></a>Vue 组件 data 为什么必须是函数，而 Vue 的根实例没有此限制</h4><p>1.Vue 组件可能存在多个实例，如果用对象形式定义 data，会导致他们共用一个 data 对象，状态改变将影响所有组件实例</p>
<p>2.采用函数形式定义，在 initData 时会将其作为工厂函数返回全新 data 对象，有效避免实例间状态污染</p>
<p>3.根实例只能有一个，不需要担心这种情况</p>
<p>4.（源码角度）源码中，数据初始化的部分会检测 data 形式从而执行具体方式。根实例创建对象时，合并选项会有实例能拿到，这是只有根实例才有的，可以有效躲过 data 形式的校验。普通组件一开始不存在实例，所以无法躲过检验的 if 逻辑，从而被检测到类型不符，无法跳过。</p>
<hr>
<h4 id="Vue-中的-key-的作用和工作原理"><a href="#Vue-中的-key-的作用和工作原理" class="headerlink" title="Vue 中的 key 的作用和工作原理"></a>Vue 中的 key 的作用和工作原理</h4><p>1.key 的主要作用是为了高效更新虚拟 DOM，从源码角度，原理就是在 patch 过程中，会执行 patchVnode，这个过程中又会执行 updateChildren，它会去更新所有两个新旧子元素，这个过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使整个 patch 更高效，减少 DOM 操作。</p>
<p>2.不设置 key 可能在列表更新时引发一些隐蔽 bug（如：更新了没有更新节点）</p>
<p>3.vue 在使用相同标签名元素的过渡切换时，也会使用到 key 属性。目的也是让 vue 可以区分它们，否则 vue 只会替换内部属性而不会触发过渡效果</p>
<h5 id="和react的key做对比"><a href="#和react的key做对比" class="headerlink" title="和react的key做对比"></a>和react的key做对比</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/newway007/article/details/104900608">https://blog.csdn.net/newway007/article/details/104900608</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhoulujun.cn/html/webfront/ECMAScript/vue/8295.html">https://www.zhoulujun.cn/html/webfront/ECMAScript/vue/8295.html</a></p>
<hr>
<h4 id="Vue-中的-diff-算法"><a href="#Vue-中的-diff-算法" class="headerlink" title="Vue 中的 diff 算法"></a>Vue 中的 diff 算法</h4><p>diff 算法并非 vue 专用，凡是涉及虚拟 DOM 都用到了 diff 算法</p>
<p>必要性：(lifecycle.js-mountComponent()) 组建中可能存在很多个 data 中的 key 使用</p>
<p>执行方式：(patch.js-patchVnode()) patchVnode 是 diff 发生的地方，整体策略：深度优先，同层比较</p>
<p>高效性：(patch.js-updateChildren)</p>
<p>1.diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 做对比（即 diff），将变化的地方更新在真实 DOM 上；另外也需要 diff 高效的执行对比过程，从而降低时间复杂度为 O(n)</p>
<p>2.Vue2.x 中为了降低 Watcher 粒度，每个组件只有一个 Watcher 与之对应，只有引入 diff 才能精确找到发生变化地方</p>
<p>3.vue 中的 diff 执行的时刻是组件实例执行其更新函数时，它会对比上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程为 patch</p>
<p>4.diff 过程整体遵循深度优先，同层比较的策略；两个节点比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点的算法是重点，首先假设头尾节点可能相同做 4 次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效</p>
<h5 id="和react的diff做比较"><a href="#和react的diff做比较" class="headerlink" title="和react的diff做比较"></a>和react的diff做比较</h5><p><a target="_blank" rel="noopener" href="https://github.com/pfan123/Articles/issues/62">https://github.com/pfan123/Articles/issues/62</a></p>
<hr>
<h4 id="Vue-组件化的理解"><a href="#Vue-组件化的理解" class="headerlink" title="Vue 组件化的理解"></a>Vue 组件化的理解</h4><p>组件定义：(src/core/global-api/assets.js)可复用的 Vue（VueComponent）实例</p>
<p>组件化优点：(lifecycle.js-mountComponent()) 每个组件有 watcher 与之对应，合理切割可以减少重新渲染面积</p>
<p>组件化实现：(构造函数，src/core/global-api/extend.js;实例和挂载，src/core/vdom/patch.js-createElm())</p>
<p>1.组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，她使开发者使用小型、独立和通常可复用的组件构建大型应用</p>
<p>2.组件化开发能大幅提高应用开发效率、测试性、复用性等</p>
<p>3.组件使用分类有：页面组件、业务组件、通用组件</p>
<p>4.vue 是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，他们基于 VueComponent 类，扩展于 Vue。扩展过程中会继承 vue 中已有的选项</p>
<p>5.vue 中常见的组件化技术有：prop，自定义事件，插槽等，他们主要用于组件通信、拓展等</p>
<p>6.合理划分组件，有助于提升应用性能</p>
<p>7.组件应该是高内聚、低耦合</p>
<p>8.遵循单项数据流的原则（修改数据提交给父组件更改或使用 vuex 更改）</p>
<hr>
<h4 id="Vue-的设计理念"><a href="#Vue-的设计理念" class="headerlink" title="Vue 的设计理念"></a>Vue 的设计理念</h4><p>1.渐进式 js 框架：自底向上逐层应用</p>
<p>2.易用性：响应式</p>
<p>3.灵活性：规模小可只保留核心功能，规模大则引入工具</p>
<p>4.高效性：虚拟 DOM，diff 算法，proxy</p>
<hr>
<h4 id="vuex-用法"><a href="#vuex-用法" class="headerlink" title="vuex 用法"></a>vuex 用法</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903949586153480">https://juejin.cn/post/6844903949586153480</a></p>
<hr>
<h4 id="对-MVC、MVP-和-MVVM-的理解"><a href="#对-MVC、MVP-和-MVVM-的理解" class="headerlink" title="对 MVC、MVP 和 MVVM 的理解"></a>对 MVC、MVP 和 MVVM 的理解</h4><p>1.三者都是框架模式，他们设计目标都是为了解决 Model 和 View 的耦合问题</p>
<p>2.MVC 模式出现较早主要应用在后端，如 Spring MVC、ASP.NET MVC 等，在前端领域的早期也有应用，如 BackBone.js。优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题</p>
<p>3.MVP 模式是 MVC 的进化形式，Presenter 作为中间层负责 MV 通信，解决了两者耦合问题，但 P 层过于臃肿会导致维护问题</p>
<p>4.MVVM 模式在前端领域有广泛应用，它不仅解决 MV 耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和 DOM 操作代码，在提高开发效率、可读性同时还保持了优越的性能问题</p>
<hr>
<h4 id="Vue3-0-新特性"><a href="#Vue3-0-新特性" class="headerlink" title="Vue3.0 新特性"></a>Vue3.0 新特性</h4><p>更快： 1.虚拟 DOM 重写 2.优化 slots 的生成 3.静态树提升 4.静态属性提升 5.基于 Proxy 的响应式系统</p>
<p>更小： 通过摇树优化核心库体积</p>
<p>更容易维护： TypeScript + 模块化</p>
<p>更友好： 跨平台，编译器核心和运行时核心与平台无关，使得 Vue 更容易与任何平台（Web、Android、ios）一起使用</p>
<p>更容易使用： 1.改进的 TypeScript 支持，编辑器能提供强有力的类型检查和错误及警告 2.更好的调试支持 3.独立的响应式模块 4.Composition API</p>
<p>1.虚拟 DOM 重写</p>
<p>期待更多的编译时提示减少运行时开销，使用更有效的代码创建虚拟节点。</p>
<p>组件快速路径+单个调用+子节点类型检测</p>
<pre><code>跳过不必要的条件分支

js引擎更容易优化</code></pre>
<p>2.优化 slots 生成</p>
<p>vue3 中可以单独重新渲染父级和子级</p>
<pre><code>确保实例正确的跟踪依赖关系

避免不必要的父子组件重新渲染</code></pre>
<p>3.静态树提升</p>
<p>使用静态树提升，意味着 vue 3 的编译器能够检测到什么是静态的，然后将其提升，从而降低了渲染成本</p>
<pre><code>跳过修补整棵树，从而降低渲染成本

即使多次出现也能正常工作</code></pre>
<p>4.静态属性提升</p>
<p>使用静态属性提升，Vue 打补丁时将跳过这些属性不会改变的节点</p>
<p>5.基于 Proxy 的数据响应式</p>
<p>Vue2 的响应式系统使用 Object.defineProperty 的 getter 和 setter。Vue3 将使用 ES2015 Proxy 作为其观察机制，这将带来以下变化</p>
<pre><code>组件实例初始化的速度提升100%

使用Proxy节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容

为了继续支持IE11，Vue3将发布一个支持旧观察机制和新Proxy版本的构建</code></pre>
<p>6.高可维护性</p>
<p>Vue3 将带来更可维护的源代码，它不仅会使用 TypeScript，而且许多包被解耦，更加模块化</p>
<hr>
<h4 id="对-Vue-生命周期的理解（结合生命周期图）"><a href="#对-Vue-生命周期的理解（结合生命周期图）" class="headerlink" title="对 Vue 生命周期的理解（结合生命周期图）"></a>对 Vue 生命周期的理解（结合生命周期图）</h4><p>1.实例化 new Vue()</p>
<pre><code>实例化之后，会执行以下操作。根据Vue源码，可看到Vue本质就是一个function。new Vue()的过程就是初始化
参数、生命周期、事件等一系列过程（src/core/instance/index.js）</code></pre>
<p>2.初始化事件 生命周期函数</p>
<pre><code>此时这个对象身上只有默认的一些生命周期和默认事件，其他东西未被创建</code></pre>
<p>3.beforeCreated(创建前)</p>
<pre><code>在实例初始化之后，数据观测（data observe）和event/watcher事件配置之前就被调用。此时拿不到data和
props里面的数据，data和methods中的数据还没初始化</code></pre>
<p>4.注射响应</p>
<pre><code>injection(注射器) reactivity(响应)给数据添加观察者</code></pre>
<p>5.created(创建后)</p>
<pre><code>在实例创建后被立即调用，此时实例已完成数据观测，属性和方法的运算，watch/event事件回调，挂载阶段还
没开始，$el尚不可用。因为上一步给数据添加了观察者，所以现在可访问到data里的数据。此钩子常用，可以
请求数据。如果要调用methods中的方法或者操作data中的数据，要在created里操作。因为请求数据是异步的，
所以发送请求宜早不宜迟。（src/core/instance/init.js initMixin）</code></pre>
<p>6.是否存在 el</p>
<pre><code>el指明挂载目标，这个步骤就是判断是否有el，如果没有就判断有没有调用实例上的$mount(&#39;&#39;)方法，这两个是
等价的。（src/core/instance/init.js）</code></pre>
<p>7.判断是否有 template</p>
<pre><code>如果有则渲染template里的内容
如果没有则渲染el指明的挂载对象里的内容（src/platforms/web/entry-runtime-with-compiler.js $mount）</code></pre>
<p>8.beforeMount(挂载前)</p>
<pre><code>挂载之前被调用，相关render函数首次被调用</code></pre>
<p>9.替换 el</p>
<pre><code>这时会在实里例上创建一个el（vm.$el），替换掉原来的el，也是真正的挂载</code></pre>
<p>10.mounted(挂载后)</p>
<pre><code>实例挂载后调用此时el已被新创建的vm.$el替换，若根实例挂载到了文档上的元素上，当mounted调用时vm.$el
也在文档内。注意mounted不会保证所有子组件一起挂载。DOM已加载完成，可以操作DOM了。只要执行完mounted，
就代表整个vue实例已经初始化完毕，一般在此操作DOM
（src/platforms/web/runtime/index.js $mount -&gt; src/core/instance/lifecycle.js mountComponent）</code></pre>
<p>11.dataChange</p>
<pre><code>当数据变化时：

在beforeUpdate发生在虚拟dom打补丁前，这时适合在更新前访问现有dom，如手动移除已添加的事件监听器
在beforeUpdate(更新前)和updated(更新后)之间会进行DOM的重新渲染和补全
（src/core/instance/lifecycle.js）

接着是updated（src/core/observer/scheduler.js callUpdatedHooks）：组件dom已更新，可执行依赖于
dom的操作，多数情况下应在此期间更改状态。
如需改变，最好使用watcher或计算属性取代。注意updated不会保证所有子组件一起被重绘</code></pre>
<p>12.callDestory(src/core/instance/lifecycle.js lifecycleMixin $destroy)</p>
<pre><code>beforeDestory(销毁前)和destroy(销毁后)这两个钩子是需要我们手动调用实例上的$destroy方法才会触发

当$destroy方法调用后

beforeDestroy销毁前触发：此时实例仍可用

移除数据劫持、事件监听、子组件属性 所有东西还保留只是不能修改

destroy销毁后触发： Vue实例所有指令被解绑，所有事件监听器被移除，所有子实例也被销毁</code></pre>
<p>13.新增钩子</p>
<pre><code>activated: keep-alive组件激活时调用，类似created没有真正创建，只是激活

deactivated: keep-alive组件停用时调用，类似destroyed没有真正移除，只是禁用

在2.2.0及其更高版本中，activated和deactivated将会在树内的所有嵌套组件中触发</code></pre>
<h5 id="父子组件生命周期顺序"><a href="#父子组件生命周期顺序" class="headerlink" title="父子组件生命周期顺序"></a>父子组件生命周期顺序</h5><p><a target="_blank" rel="noopener" href="https://m.html.cn/qa/vue-js/22535.html">https://m.html.cn/qa/vue-js/22535.html</a></p>
<hr>
<h4 id="nextTick-原理"><a href="#nextTick-原理" class="headerlink" title="nextTick 原理"></a>nextTick 原理</h4><p>vue 如何检测到 DOM 更新完毕：MutationObserver API<br>MutationObserver：是 HTML5 新增属性，用于监听 DOM 修改事件，能见听到节点的属性、文本内容、子节点等的改动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(function() &#123;</span><br><span class="line">    console.log(&#39;DOM被修改了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">var article &#x3D; document.querySelector(&#39;article&#39;)</span><br><span class="line">observer.observer(article)</span><br></pre></td></tr></table></figure>

<p>vue 中的 nextTick 实现(src/core/util/env.js):</p>
<pre><code>如果检测到浏览器支持MutationObserver则创建一个文本节点，监听文本节点的改动，以此触发nextTickHandler，也就
是dom更新完毕的回调的执行</code></pre>
<p>事件循环机制（Event Loop）</p>
<pre><code>浏览器使用事件循环机制协调各种事件的处理。
事件循环会维护一个或多个任务队列，事件作为任务源往队列中加入任务，每执行完一个就从队列中移除它，这就是一次事
件循环

setTimeOut就是在队列末尾加入了一个任务

每次事件循环最后都会有一个ui render步骤即更新dom
for循环同属一个task，浏览器只在task执行完后进行一次dom更新

所以vue运用此思路，并不是用MutationObserver监听dom，而是用队列控制的方式达到目的

vue数据响应过程包含：数据更改-&gt;通知watcher-&gt;更新dom。而数据更改不受我们控制，可能在任何时候发生，如果刚好
在重绘之前，就会发生多次渲染，性能浪费，这是vue不希望的。

于是vue的队列控制还需要了解microtask</code></pre>
<p>microtask 微任务</p>
<pre><code>每次事件循环都包含一个微任务队列，在循环结束后依次执行队列中的微任务并移除，再开始下一次事件循环

宏任务要等为任务执行完才能执行，微任务有更高的优先级

microtask此特性是做队列控制的最佳选择，vue进行DOM更新内部也是调用nextTick来做异步队列控制。当我们调用
nextTick，它就在更新DOM的那个微任务后追加了我们自己的回调函数，从而确保我们的代码在DOM更新后执行，也避
免了setTimeOut可能存在的多次执行问题

常见微任务：Promise、MutationObserver、Object.observer(已废弃)、以及node.js中的process.nextTick

vue用MutationObserver是想利用其微任务特性而并非做DOM监听，用不用都行，在vue2.5版本中已删去了
MutationObserver相关代码，因为它是HTML5新增的特性，在IOS上尚有bug

最优的微任务策略就是Promise，但是Promise是es6新特性，也存在兼容问题，于是vue面临降级策略</code></pre>
<p>Vue 的降级策略</p>
<pre><code>如果当前环境不支持Promise，vue只能降级为宏任务(macrotask)来做队列控制

setTimeOut执行的最小时间间隔是4ms左右，会比较延迟，不是最优方案

在vue2.5源码中，宏任务降级方案依次为：setimmadiate, MessageChannel, setTimeOut
setimmadiate最理想但是只有IE和node.js支持
MessageChannel的onmessage回调也是microtask，但也是个新API，面临兼容问题
setTimeOut是兜底方案</code></pre>
<p>总结：</p>
<pre><code>1.vue用异步队列的方式控制DOM更新和nextTick回调先后执行

2.microtask因为其优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕

3.因为兼容性问题，vue不得不做了microtask向macrotask的降级方案

4.触发时机：同一事件循环中的数据变化后，dom完成更新，立即执行nextTick的回调</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leiting/p/13174545.html">https://www.cnblogs.com/leiting/p/13174545.html</a></p>
<hr>
<h4 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h4><p>设计思想：观察者模式</p>
<p>Dep 对象：Dependency 依赖中心。依赖的简写。包含三个主要属性：id，subs，target 和四个主要函数 addSub，removeSub，depend，<br>notify，是观察者的依赖集合，负责在数据发生改变时，使用 notify 触发保存在 subs 下的订阅列表，依次更新数据和 DOM</p>
<p>Observer 对象：即观察者，包含两个主要属性 value，dep。做法是使用 getter、setter 方法覆盖默认的取值和赋值操作，将对象<br>封装为响应式对象，每一次调用时更新依赖列表，更新值时触发订阅者。绑定在对象的 ob 原型链属性上</p>
<p>Watcher： 订阅者，当某个观察者观察到数据发生变化的时候，这个变化经过消息调度中心，最终会传递到所有该观察者对应的订阅者身上，然后这些订阅者分别执行自身的业务回调即可</p>
<p>vue 数据双向绑定通过‘数据劫持’ + 订阅发布模式实现</p>
<p>数据劫持: 指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行 额外的操作或者修改返回结果 典型的有</p>
<pre><code>1.Object.defineProperty()
2.es6 中 Proxy 对象(兼容性不太好)
vue2.x 使用 Object.defineProperty();
vue3.x 使用 Proxy;</code></pre>
<p>订阅发布模式: 对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依 赖于它的对象都将得到通知 订阅发布模式<br>中事件统一由处理中心处理，订阅者发布者互不干扰。</p>
<p>优点: 实现更多的控制，做权限处理，节流控制之类，例如:发布了很多消息，但是不是 所有订阅者都要接收</p>
<p>vue 中如何实现:</p>
<pre><code>利用 Object.defineProperty();把内部解耦为三部分
Observer: 递归的监听对象上的所有属性，当属性改变时触发对应的 watcher
watcher(观察者): 当监听的数据值修改时，执行相应的回调函数，更新模板内容 dep:链接 observer 和 watcher，每
一个observer 对应一个 dep,内部维护一个数组，保存 与该 observer 相关的 watcher
proxy 实现观察者模式: 观察者模式(Observer mode)指的是函数自动观察数据对象，一 旦对象有变化，函数就会自动执
行</code></pre>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6868085927685095437">https://juejin.cn/post/6868085927685095437</a></p>
<hr>
<h4 id="vue双向绑定的原理"><a href="#vue双向绑定的原理" class="headerlink" title="vue双向绑定的原理"></a>vue双向绑定的原理</h4><p>1）v-model 属性<br>针对于 input 的 v-model 双向数据绑定实际上就是通过子组件中的 $emit 方法派发 input 事件，父组件监听 input 事件中传递的 value 值，并存储在父组件 data 中；然后父组件再通过 prop 的形式传递给子组件 value 值，再子组件中绑定 input 的 value 属性即可。<br>其他元素使用 v-model 双向数据绑定实际上就是，通过监听 change 事件。以及$emit 方法派发，再通过 prop 的形式传递。</p>
<p>2）.sync 修饰符<br>父组件向子组件传递数据的方式有多种，props 是其中的一种，但是它的局限在于数据只能单向传递，子组件不能直接修改 prop 属性，但是碰到子组件需要修改父组件的情况怎么办呢？<br>父组件中并没有定义过 update 事件，但是却可以完成 prop 属性 page 的修改，这就是 sync 语法糖的作用。</p>
<hr>
<h4 id="Object-defineProperty-和-Proxy-的区别"><a href="#Object-defineProperty-和-Proxy-的区别" class="headerlink" title="Object.defineProperty 和 Proxy 的区别"></a>Object.defineProperty 和 Proxy 的区别</h4><p>defineproperty 只能监听某个属性不能全对象监听，proxy 不用设置具体属性</p>
<pre><code>defineproperty监听需要知道那个对象的那个属性，而proxy只需要知道那个对象就可以了。也就是会省去for in 循环
提高了效率</code></pre>
<p>proxy 不需要借助外部 value，也有单独相配的对象即 Reflect</p>
<pre><code>eg：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ob&#x3D;&#123;a:1,b:2&#125;</span><br></pre></td></tr></table></figure>
在proxy的get里面有target，key，receiver三个值，其中target是对象ob，key是ob.a，receiver是，set里面除了这
三个额外多加了一个value，value是传出来的新值。所以在get里return的就是target[key]，set里面return的是
target[key]=value或者用proxy里的Reflect.set(target，key，value）这样写优雅一点</code></pre>
<p>不会污染原对象（关键区别）</p>
<pre><code>proxy去代理了ob，他会返回一个新的代理对象不会对原对象ob进行改动，而defineproperty是去修改元对象，修改元对
象的属性，而proxy只是对元对象进行代理并给出一个新的代理对象</code></pre>
<hr>
<h4 id="模板语法的实现原理"><a href="#模板语法的实现原理" class="headerlink" title="模板语法的实现原理"></a>模板语法的实现原理</h4><p>Vue 通过它的编译器将模板编译成渲染函数，在数据发生变化时在此执行渲染函数，通过对比两次执行结果得<br>出要做的 dom 操作</p>
<hr>
<h4 id="vue插槽"><a href="#vue插槽" class="headerlink" title="vue插槽"></a>vue插槽</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903920037281805#heading-2">https://juejin.cn/post/6844903920037281805#heading-2</a></p>
<hr>
<h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>用法 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903919273918477">https://juejin.cn/post/6844903919273918477</a></p>
<p>原理 <a target="_blank" rel="noopener" href="https://bbchin.com/archives/source-keep-alive">https://bbchin.com/archives/source-keep-alive</a></p>
<hr>
<h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><p>v-show（会导致回流）</p>
<p>v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。</p>
<p>v-if（增删dom）</p>
<p>在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。</p>
<p>性能方面<br>v-if绝对是更消耗性能的，因为v-if在显示隐藏过程中有DOM的添加和删除，v-show就简单多了，只是操作css。</p>
<p>使用场景<br>因为v-show无论如何都会渲染，如果在一些场景下很难出现，那么使用v-if。如果是一些固定的，条件内容都不怎么会改变的，频繁切换的，使用v-show会比较省性能。如果是子组件，每次切换子组件不执行生命周期，使用v-show，如果子组件需要重新执行生命周期，那么使用v-if才能触发。</p>
<hr>
<h4 id="vue的数组操作方法"><a href="#vue的数组操作方法" class="headerlink" title="vue的数组操作方法"></a>vue的数组操作方法</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6941348666422919204">https://juejin.cn/post/6941348666422919204</a></p>
<p>vue的set方法原理是splice()</p>
<hr>
<h4 id="vue数据变化视图不更新的情况"><a href="#vue数据变化视图不更新的情况" class="headerlink" title="vue数据变化视图不更新的情况"></a>vue数据变化视图不更新的情况</h4><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022772025">https://segmentfault.com/a/1190000022772025</a></p>
<hr>
<h4 id="vue更新数组时触发视图更新的方法"><a href="#vue更新数组时触发视图更新的方法" class="headerlink" title="vue更新数组时触发视图更新的方法"></a>vue更新数组时触发视图更新的方法</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_57550930/article/details/120422295">https://blog.csdn.net/weixin_57550930/article/details/120422295</a></p>
<hr>
<h4 id="Vue-常用修饰符"><a href="#Vue-常用修饰符" class="headerlink" title="Vue 常用修饰符"></a>Vue 常用修饰符</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64969829/article/details/122881221">https://blog.csdn.net/m0_64969829/article/details/122881221</a></p>
<hr>
<h4 id="Vue在父组件中使用子组件生命周期"><a href="#Vue在父组件中使用子组件生命周期" class="headerlink" title="Vue在父组件中使用子组件生命周期"></a>Vue在父组件中使用子组件生命周期</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rainbowLover/p/13229003.html">https://www.cnblogs.com/rainbowLover/p/13229003.html</a></p>
<hr>
<h4 id="特殊问题解决"><a href="#特殊问题解决" class="headerlink" title="特殊问题解决"></a>特殊问题解决</h4><h5 id="在-Vue-中如何实现父组件与子组件之间的数据同步？如何确保在父组件更新数据时，子组件能够及时接收到更新，但在子组件中修改数据不会直接影响父组件的数据？"><a href="#在-Vue-中如何实现父组件与子组件之间的数据同步？如何确保在父组件更新数据时，子组件能够及时接收到更新，但在子组件中修改数据不会直接影响父组件的数据？" class="headerlink" title="在 Vue 中如何实现父组件与子组件之间的数据同步？如何确保在父组件更新数据时，子组件能够及时接收到更新，但在子组件中修改数据不会直接影响父组件的数据？"></a>在 Vue 中如何实现父组件与子组件之间的数据同步？如何确保在父组件更新数据时，子组件能够及时接收到更新，但在子组件中修改数据不会直接影响父组件的数据？</h5><p>在 Vue 中，父组件通过 props 向子组件传递数据，子组件可以通过 emit 向父组件发送事件以更新数据。如果需要确保父组件的数据更新时子组件接收最新数据，而子组件修改数据不直接影响父组件，可以使用 v-model 在子组件中实现双向绑定，或使用数据拷贝</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent :value=<span class="string">&quot;parentData&quot;</span> @update:value=<span class="string">&quot;parentData = $event&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input :value=<span class="string">&quot;value&quot;</span> @input=<span class="string">&quot;$emit(&#x27;update:value&#x27;, $event.target.value)&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">props: [<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="在-Vue-中，当使用-v-model-实现双向数据绑定时，如何自定义组件使其能够与-v-model-配合工作？"><a href="#在-Vue-中，当使用-v-model-实现双向数据绑定时，如何自定义组件使其能够与-v-model-配合工作？" class="headerlink" title="在 Vue 中，当使用 v-model 实现双向数据绑定时，如何自定义组件使其能够与 v-model 配合工作？"></a>在 Vue 中，当使用 v-model 实现双向数据绑定时，如何自定义组件使其能够与 v-model 配合工作？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input :value=<span class="string">&quot;modelValue&quot;</span> @input=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">&#x27;modelValue&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="在-Vue-3-中使用-Composition-API-时，如何在多个组件之间共享逻辑而避免代码重复？请解释如何使用-composables。"><a href="#在-Vue-3-中使用-Composition-API-时，如何在多个组件之间共享逻辑而避免代码重复？请解释如何使用-composables。" class="headerlink" title="在 Vue 3 中使用 Composition API 时，如何在多个组件之间共享逻辑而避免代码重复？请解释如何使用 composables。"></a>在 Vue 3 中使用 Composition API 时，如何在多个组件之间共享逻辑而避免代码重复？请解释如何使用 composables。</h5><p>在 Vue 3 中，composables 是用来复用逻辑的函数，通常以 useXxx 命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useCounter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> count.value++;</span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./useCounter&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; count, increment &#125; = useCounter();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="你正在开发一个复杂的-Vue-应用，需要在某个组件的-created-钩子中请求数据并将其存储在-data-中，但在请求完成前组件可能会被销毁。如何避免请求未完成导致的内存泄漏？"><a href="#你正在开发一个复杂的-Vue-应用，需要在某个组件的-created-钩子中请求数据并将其存储在-data-中，但在请求完成前组件可能会被销毁。如何避免请求未完成导致的内存泄漏？" class="headerlink" title="你正在开发一个复杂的 Vue 应用，需要在某个组件的 created 钩子中请求数据并将其存储在 data 中，但在请求完成前组件可能会被销毁。如何避免请求未完成导致的内存泄漏？"></a>你正在开发一个复杂的 Vue 应用，需要在某个组件的 created 钩子中请求数据并将其存储在 data 中，但在请求完成前组件可能会被销毁。如何避免请求未完成导致的内存泄漏？</h5><p>在异步请求中可使用标志变量或取消请求的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">isMounted</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">this</span>.fetchData();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    <span class="built_in">this</span>.isMounted = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> fetchData() &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> fetchSomeData();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isMounted) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Vue-中使用-ref-和-reactive-有什么区别？在什么情况下使用-ref-比-reactive-更合适？"><a href="#Vue-中使用-ref-和-reactive-有什么区别？在什么情况下使用-ref-比-reactive-更合适？" class="headerlink" title="Vue 中使用 ref 和 reactive 有什么区别？在什么情况下使用 ref 比 reactive 更合适？"></a>Vue 中使用 ref 和 reactive 有什么区别？在什么情况下使用 ref 比 reactive 更合适？</h5><p>ref 适用于简单值和需要解包的场景（例如基础类型）。<br>reactive 适合用于对象和嵌套结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>); <span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">const</span> user = reactive(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;); <span class="comment">// 对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="在-Vue-项目中，如何确保一个组件在-beforeRouteLeave-钩子中阻止用户在未保存更改的情况下离开当前页面？"><a href="#在-Vue-项目中，如何确保一个组件在-beforeRouteLeave-钩子中阻止用户在未保存更改的情况下离开当前页面？" class="headerlink" title="在 Vue 项目中，如何确保一个组件在 beforeRouteLeave 钩子中阻止用户在未保存更改的情况下离开当前页面？"></a>在 Vue 项目中，如何确保一个组件在 beforeRouteLeave 钩子中阻止用户在未保存更改的情况下离开当前页面？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSaved) &#123;</span><br><span class="line">      <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;You have unsaved changes. Do you really want to leave?&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="如何在-Vue-项目中动态加载和使用外部插件，而不在项目启动时直接引入？"><a href="#如何在-Vue-项目中动态加载和使用外部插件，而不在项目启动时直接引入？" class="headerlink" title="如何在 Vue 项目中动态加载和使用外部插件，而不在项目启动时直接引入？"></a>如何在 Vue 项目中动态加载和使用外部插件，而不在项目启动时直接引入？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadPlugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;some-external-plugin&#x27;</span>);</span><br><span class="line">  <span class="built_in">module</span>.default();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="在使用-Vuex-时，如何确保异步操作在多个组件中不会造成数据竞争条件或不一致问题？"><a href="#在使用-Vuex-时，如何确保异步操作在多个组件中不会造成数据竞争条件或不一致问题？" class="headerlink" title="在使用 Vuex 时，如何确保异步操作在多个组件中不会造成数据竞争条件或不一致问题？"></a>在使用 Vuex 时，如何确保异步操作在多个组件中不会造成数据竞争条件或不一致问题？</h5><p>确保所有异步调用在 Vuex 中的 actions 中完成，并使用 Promise 链或 async/await 来协调多个请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> fetchData(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> apiCall();</span><br><span class="line">    commit(<span class="string">&#x27;setData&#x27;</span>, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Vue-3-的-teleport-是什么？请举例说明如何在应用中使用它来优化布局或样式管理。"><a href="#Vue-3-的-teleport-是什么？请举例说明如何在应用中使用它来优化布局或样式管理。" class="headerlink" title="Vue 3 的 teleport 是什么？请举例说明如何在应用中使用它来优化布局或样式管理。"></a>Vue 3 的 teleport 是什么？请举例说明如何在应用中使用它来优化布局或样式管理。</h5><p>teleport 用来将 DOM 渲染到当前组件树外部的目标位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;teleport to=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;modal&quot;</span>&gt;This is a modal&lt;/div&gt;</span><br><span class="line">  &lt;/teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="如何在-Vue-中通过事件总线实现兄弟组件之间的通信？在-Vue-3-中，有哪些更推荐的方法替代事件总线？"><a href="#如何在-Vue-中通过事件总线实现兄弟组件之间的通信？在-Vue-3-中，有哪些更推荐的方法替代事件总线？" class="headerlink" title="如何在 Vue 中通过事件总线实现兄弟组件之间的通信？在 Vue 3 中，有哪些更推荐的方法替代事件总线？"></a>如何在 Vue 中通过事件总线实现兄弟组件之间的通信？在 Vue 3 中，有哪些更推荐的方法替代事件总线？</h5><p>1.provide 和 inject 是 Vue 3 中常用的用于祖先组件和后代组件之间共享数据的 API。它可以实现跨层级的通信，避免层层传递 props</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(<span class="string">&#x27;sharedData&#x27;</span>, <span class="string">&#x27;Hello from ancestor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> sharedData = inject(<span class="string">&#x27;sharedData&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; sharedData &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; sharedData &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.全局状态管理</p>
<p>3.Composable Functions</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useSharedState.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sharedValue = ref(<span class="string">&#x27;Initial value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useSharedState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; sharedValue &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useSharedState &#125; <span class="keyword">from</span> <span class="string">&#x27;./useSharedState&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; sharedValue &#125; = useSharedState();</span><br><span class="line">    <span class="keyword">return</span> &#123; sharedValue &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>

            <br />
            <p class="meta">
                
            </p>
        </div>

        <div class="col-sm-3">
             
<span><b> TL;DR</b></span>
<p>
	Yet another hexo theme.
</p>
<hr />


<span><b> TL;DR 2</b></span>
<p>
	No, not another one :/
</p>
<hr />

 

<span
	><a href="https://twitter.com/hexojs" target="_blank" rel="noopener"
		><b
			><i class="fab fa-twitter-square"></i>
			<i class="fas fa-at"></i>
			hexojs</b
		></a
	></span
>
<br />
<a class="twitter-timeline" data-height="800" data-dnt="true" data-chrome="nofooter transparent noheader noborders " target="_blank" rel="noopener" href="https://twitter.com/hexojs?ref_src=twsrc%5Etfw"></a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


        </div>
    </div>
</div>
<!-- Menu fade on scroll -->
<script>
    var isScrolling;
    var prevScrollpos = window.pageYOffset;
    window.addEventListener(
        'scroll',
        function(event) {
            window.clearTimeout(isScrolling);
            isScrolling = setTimeout(function() {
                var currentScrollPos = window.pageYOffset;
                if (prevScrollpos > currentScrollPos) {
                    $('#navbar').slideDown();
                } else {
                    $('#navbar').slideUp();
                }
                prevScrollpos = currentScrollPos;
            }, 66);
        },
        false
    );
</script>


<a class="float-left gradient btn paginationbtn" href="/2023/07/13/sortArithmetic/"><i class="fas fa-chevron-left"></i></a>


<a class="float-right gradient btn paginationbtn" href="/2023/07/13/webpack/"><i class="fas fa-chevron-right"></i></a>

    </main>
    <!-- Footer -->
    <footer class="page-footer">
  <div class="container">
    <div class="social-icons">
      
      <a href="https://hexo.io/" title="Hexo.io" target="_blank" rel="noopener" class="fas fa-home"></a>
      
      <a href="https://twitter.com/hexojs" title="@hexojs" target="_blank" rel="noopener" class="fab fa-twitter"></a>
      
      <a href="https://github.com/RandomAdversary/Gradient/issues" title="Report issue" target="_blank" rel="noopener" class="fas fa-bug"></a>
      
    </div>
  </div>
</footer>
    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
    crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
    crossorigin="anonymous"></script>
</body>

</html>